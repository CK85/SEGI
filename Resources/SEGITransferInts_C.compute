#pragma kernel CSMain
#pragma kernel CSMain2
#pragma kernel CSMainColor

RWTexture3D<float4> Result;
Texture3D<float4> PrevResult;

Texture2DArray<uint> RG0;

SamplerState _PointClamp;

int Resolution;
int VoxelAA;

float4 VoxelOriginDelta;

float4 ClipmapOverlap;
float4 SEGI_GRID_SIZE;

//float2 IntToFloats(uint intval)
//{
//	float value1 = f16tof32(intval);
//	float value2 = f16tof32(intval / 0x0000FFFF);
//	return float2(value1, value2);
//}

float3 hsv2rgb(float3 c)
{
	float4 k = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + k.xyz) * 6.0 - k.www);
	return c.z * lerp(k.xxx, saturate(p - k.xxx), c.y);
}

float4 DecodeRGBAuint(uint value)
{
	//const float div = 1.0f / 255.0f;
	//float4 colorOut = float4((value & 0xFF) * div, ((value & 0xFFFF) >> 8) * div, ((value & 0xFFFFFF) >> 16) * div, (value >> 24) * div);
	//colorOut.a *= 2.0;
	//return colorOut;

	uint ai = value & 0x0000007F;
	uint vi = (value / 0x00000080) & 0x000007FF;
	uint si = (value / 0x00040000) & 0x0000007F;
	uint hi = value / 0x02000000;

	float h = float(hi) / 127.0;
	float s = float(si) / 127.0;
	float v = (float(vi) / 2047.0) * 10.0;
	float a = ai * 2.0;

	v = pow(v, 3.0);

	float3 color = hsv2rgb(float3(h, s, v));

	return float4(color.rgb, a);
}

[numthreads(16,16,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    for (int i = 0; i < Resolution; i++)
    {
    	float4 result = float4(0,0,0,0);

		const float4 gridSize = SEGI_GRID_SIZE;
		uint3 coord = uint3(id.x, id.y, i);
		uint2 coord2D = uint2(coord.x + gridSize.x*(coord.z%gridSize.w), coord.y + gridSize.y*(coord.z / gridSize.w));

		result.rgba = DecodeRGBAuint(RG0[uint3(coord2D,0)]);

		result /= 1 + VoxelAA * 3;

		result.rgb /= max(result.a, 2.0);

		float blockerValue = 0.0;

		if (result.a > 20.0)
		{
			blockerValue = max(0.0, result.a - 20.0);
		}

		result.a = min(result.a, 2.0) * 1.0;
		result.a += blockerValue;
		
		Result[uint3(id.xy, i)] = result;

    }
}

[numthreads(16,16,1)]
void CSMain2 (uint3 id : SV_DispatchThreadID)
{
    for (int i = 0; i < Resolution; i++)
    {
    	float4 result = float4(0,0,0,0);

		const float4 gridSize = SEGI_GRID_SIZE;
		uint3 coord = uint3(id.x, id.y, i);
		uint2 coord2D = uint2(coord.x + gridSize.x*(coord.z%gridSize.w), coord.y + gridSize.y*(coord.z / gridSize.w));

		result.rgba = DecodeRGBAuint(RG0[uint3(coord2D,0)]);

		result.rgb /= max(2.0, result.a);

        Result[uint3(id.xy, i)] = result;
    }
}

float3 TransformClipSpace(float3 pos, float4 transform)
{
	pos = pos * 2.0 - 1.0;
	pos *= transform.w;
	pos = pos * 0.5 + 0.5;
	pos -= transform.xyz;

	return pos;
}

uint SEGICurrentClipmapIndex;
float SEGIShadowBias;
float SEGISecondaryBounceGain;
float4 SEGIVoxelSpaceOriginDelta;

float4 SEGIShadowClipTransform1;
float4 SEGIShadowClipTransform2;
float4 SEGIShadowClipTransform3;
float4 SEGIShadowClipTransform4;
float4 SEGIShadowClipTransform5;
float4x4 SEGIVoxelProjectionInverse;
float4x4 SEGIVoxelProjectionInverse1;
float4x4 SEGIVoxelProjectionInverse2;
float4x4 SEGIVoxelProjectionInverse3;
float4x4 SEGIVoxelProjectionInverse4;
float4x4 SEGIVoxelProjectionInverse5;
float4x4 SEGIVoxelToGIProjection;
float4x4 SEGIVoxelToGIProjection1;
float4x4 SEGIVoxelToGIProjection2;
float4x4 SEGIVoxelToGIProjection3;
float4x4 SEGIVoxelToGIProjection4;
float4x4 SEGIVoxelToGIProjection5;

sampler2D SEGISunDepth;
sampler2D SEGISunDepth1;
sampler2D SEGISunDepth2;
sampler2D SEGISunDepth3;
sampler2D SEGISunDepth4;
sampler2D SEGISunDepth5;
sampler3D SEGICurrentIrradianceVolume;


[numthreads(16, 16, 1)]
void CSMainColor(uint3 id : SV_DispatchThreadID)
{
	for (int i = 0; i < Resolution; i++)
	{
		float4 result = float4(0, 0, 0, 0);
		float4 colShaded = float4(0, 0, 0, 0);
		float4 colEmission = float4(0, 0, 0, 0);

		const float4 gridSize = SEGI_GRID_SIZE;
		uint3 coord = uint3(id.x, id.y, i);
		uint2 coord2D = uint2(coord.x + gridSize.x*(coord.z%gridSize.w), coord.y + gridSize.y*(coord.z / gridSize.w));

		result = DecodeRGBAuint(RG0[uint3(coord2D, 0)]);
		colShaded = DecodeRGBAuint(RG0[uint3(coord2D, 1)]);
		colEmission = DecodeRGBAuint(RG0[uint3(coord2D, 2)]);

		float3 fcoord = uint3(id.x, id.y, i) / float(Resolution);

		//TODO add more
		float4 shadowPos = mul(SEGIVoxelProjectionInverse5, float4(TransformClipSpace(fcoord, SEGIShadowClipTransform5) * 2.0 - 1.0, 0.0));
		shadowPos = mul(SEGIVoxelToGIProjection5, shadowPos);
		shadowPos.xyz = shadowPos.xyz * 0.5 + 0.5;
		float sunDepth = tex2Dlod(SEGISunDepth5, float4(shadowPos.xy, 0, 0)).x;
		//#if defined(UNITY_REVERSED_Z)
		sunDepth = 1.0 - sunDepth;
		//#endif
		float sunVisibility5 = saturate((sunDepth - shadowPos.z + SEGIShadowBias) * 1000);


		shadowPos = mul(SEGIVoxelProjectionInverse4, float4(TransformClipSpace(fcoord, SEGIShadowClipTransform4) * 2.0 - 1.0, 0.0));
		shadowPos = mul(SEGIVoxelToGIProjection4, shadowPos);
		shadowPos.xyz = shadowPos.xyz * 0.5 + 0.5;
		sunDepth = tex2Dlod(SEGISunDepth4, float4(shadowPos.xy, 0, 0)).x;
		//#if defined(UNITY_REVERSED_Z)
		sunDepth = 1.0 - sunDepth;
		//#endif
		float sunVisibility4 = saturate((sunDepth - shadowPos.z + SEGIShadowBias) * 1000);

		shadowPos = mul(SEGIVoxelProjectionInverse3, float4(TransformClipSpace(fcoord, SEGIShadowClipTransform3) * 2.0 - 1.0, 0.0));
		shadowPos = mul(SEGIVoxelToGIProjection3, shadowPos);
		shadowPos.xyz = shadowPos.xyz * 0.5 + 0.5;
		sunDepth = tex2Dlod(SEGISunDepth3, float4(shadowPos.xy, 0, 0)).x;
		//#if defined(UNITY_REVERSED_Z)
		sunDepth = 1.0 - sunDepth;
		//#endif
		float sunVisibility3 = saturate((sunDepth - shadowPos.z + SEGIShadowBias) * 1000);

		shadowPos = mul(SEGIVoxelProjectionInverse2, float4(TransformClipSpace(fcoord, SEGIShadowClipTransform2) * 2.0 - 1.0, 0.0));
		shadowPos = mul(SEGIVoxelToGIProjection2, shadowPos);
		shadowPos.xyz = shadowPos.xyz * 0.5 + 0.5;
		sunDepth = tex2Dlod(SEGISunDepth2, float4(shadowPos.xy, 0, 0)).x;
		//#if defined(UNITY_REVERSED_Z)
		sunDepth = 1.0 - sunDepth;
		//#endif
		float sunVisibility2 = saturate((sunDepth - shadowPos.z + SEGIShadowBias) * 1000);

		shadowPos = mul(SEGIVoxelProjectionInverse1, float4(TransformClipSpace(fcoord, SEGIShadowClipTransform1) * 2.0 - 1.0, 0.0));
		shadowPos = mul(SEGIVoxelToGIProjection1, shadowPos);
		shadowPos.xyz = shadowPos.xyz * 0.5 + 0.5;
		sunDepth = tex2Dlod(SEGISunDepth1, float4(shadowPos.xy, 0, 0)).x;
		//#if defined(UNITY_REVERSED_Z)
		sunDepth = 1.0 - sunDepth;
		//#endif
		float sunVisibility1 = saturate((sunDepth - shadowPos.z + SEGIShadowBias) * 1000);

		shadowPos = mul(SEGIVoxelProjectionInverse, float4(fcoord * 2.0 - 1.0, 0.0));
		shadowPos = mul(SEGIVoxelToGIProjection, shadowPos);
		shadowPos.xyz = shadowPos.xyz * 0.5 + 0.5;
		sunDepth = tex2Dlod(SEGISunDepth, float4(shadowPos.xy, 0, 0)).x;
		//#if defined(UNITY_REVERSED_Z)
		sunDepth = 1.0 - sunDepth;
		//#endif
		float sunVisibility = saturate((sunDepth - shadowPos.z + SEGIShadowBias) * 1000);
		float tempSadow = sunVisibility;

		if (SEGICurrentClipmapIndex == 0)
			sunVisibility = (sunVisibility + sunVisibility1 * 6 + sunVisibility2 * 4 + sunVisibility3 * 2 + sunVisibility4 + sunVisibility5) / 15.0f;

		if (SEGICurrentClipmapIndex == 1)
			sunVisibility = (sunVisibility * 2 + sunVisibility2 * 4 + sunVisibility3 * 2 + sunVisibility4 + sunVisibility5) / 10.0f;

		if (SEGICurrentClipmapIndex == 2)
			sunVisibility = (sunVisibility * 4 + sunVisibility3 * 2 + sunVisibility4 + sunVisibility5) / 8.0f;

		if (SEGICurrentClipmapIndex == 3)
			sunVisibility = (sunVisibility * 6 + sunVisibility4 + sunVisibility5) / 8.0f;

		if (SEGICurrentClipmapIndex == 4)
			sunVisibility = (sunVisibility * 8 + sunVisibility5) / 9.0f;


		sunVisibility = saturate(((sunVisibility - 0.5f) * max(3, 0)) + 0.5f);

		float3 color = result.rgb;
		result.rgb = color * colShaded.rgb * sunVisibility + colEmission.rgb;

		float4 prevBounce = tex3Dlod(SEGICurrentIrradianceVolume, float4(fcoord + SEGIVoxelSpaceOriginDelta.xyz,0));
		result.rgb += prevBounce.rgb * 0.2 * SEGISecondaryBounceGain * color.rgb;// tex.rgb * color.rgb;


		result /= 1 + VoxelAA * 3;

		result.rgb /= max(result.a, 2.0);

		float blockerValue = 0.0;

		if (result.a > 20.0)
		{
			blockerValue = max(0.0, result.a - 20.0);
		}

		result.a = min(result.a, 2.0) * 1.0;
		result.a += blockerValue;

		Result[uint3(id.xy, i)] = result;

	}
}
